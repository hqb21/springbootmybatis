命名规约:
1. 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束;
2. 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式;
3. 类名使用UpperCamelCase风格，必须遵从驼峰形式（某些情况诸如领域模型相关的命名除外）；方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式;
4. 常量命名全部大写，单词间用下划线隔开;
5. 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词;
6. 类名使用UpperCamelCase风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO等;

命名原则:
1. 力求语义表达完整清楚，不要嫌名字长;
2. 杜绝完全不规范的缩写，避免望文不知义;
这两条说的是命名的基本原则，总的来说其实表达了一个意思：你他妈的别给我用缩写！
比如非常典型的就是：UserMgmt，这他妈是什么鬼？多敲几个字母会死么？

类的命名:
1. 抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾;
2. 对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别;
3. 如果是形容能力的接口名称，取对应的形容词做接口名;
4. 枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开;
5. 如果使用到了设计模式，建议在类名中体现出具体模式;
6. 包名统一使用单数形式，类名如果有复数含义，类名可以使用复数形式;
7. 提供一系列静态方法的工具类，一概使用Utils作为后缀命名;

常量规约：
1. 不允许出现任何魔法值（即未经定义的常量）直接出现在代码中;
2. 不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护;
3. 常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量;
4. 如果变量值仅在一个范围内变化用Enum类。如果还带有名称之外的延伸属性，必须使用Enum类;
5. 尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量;
6. 常量规约的核心有两点：第一，别使用常量；第二，让常量可控。

语法糖：
1. 慎用Object的clone方法来拷贝对象;
2. 接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释;
3. 所有的覆写方法，必须加@Override注解;
4. 可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）;
5. 对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么;
6. 不能使用过时的类或方法;
7. 序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败;
8. 循环体内，字符串的联接方式，使用StringBuilder的append;
9. final可提高程序响应效率;

基本类型：
1. 所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较;
2. 所有的POJO类属性必须使用包装数据类型;
3. RPC方法的返回值和参数必须使用包装数据类型;
4. 所有的局部变量【推荐】使用基本数据类型;

方法命名：
1.  Service/DAO层方法命名规约
    - 获取单个对象的方法用get做前缀
    - 获取多个对象的方法用list做前缀
    - 获取统计值的方法用count做前缀
    - 插入的方法用save（推荐）或insert做前缀
    - 删除的方法用remove（推荐）或delete做前缀
    - 修改的方法用update做前缀
    - Service层接口方法的命名，应还原业务的本来面目，采用动词或者动宾结构来进行方法的命名;

方法和属性：
1. 定义DO/DTO/VO等POJO类时，不要设定任何属性默认值;
2. 构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中;
3. 当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读;
4. 类内方法定义顺序依次是：公有方法或保护方法 > 私有方法 > getter/setter方法;
5. setter方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter/setter方法中，尽量不要增加业务逻辑;
6. 类成员与方法访问控制从严;

格式规范：
1. 缩进采用4个空格，禁止使用tab字符;
2. 单行字符数限不超过 120 个;
3. IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式，不要使用windows格式;
4. 方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行;

并发处理：
1. 获取单例对象需要保证线程安全，其中的方法也要保证线程安全;
2. 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯;
3. 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程;
4. 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor去创建;
5. 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁;
6. 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁;
7. 并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据;
9. 多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题;
10. 使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法可以执行，避免主线程无法执行至countDown方法，直到超时才返回结果回溯;
11. volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题;
12. HashMap在容量不够进行resize时由于高并发可能出现死链;
13. ThreadLocal无法解决共享对象的更新问题，ThreadLocal对象建议使用static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量;

注释规范：
1. 所有的枚举类型字段必须要有注释，说明每个数据项的用途;
2. 与其"半吊子"英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可;
3. 注释掉的代码尽量要配合说明，而不是简单的注释掉;
4. 好的命名、代码结构是自解释的，注释力求精简准确、表达到位;

数据库规范：
1. 是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（ 1表示是，0表示否）;
2. 表名、字段名必须使用小写字母或数字；禁止出现数字开头，禁止两个下划线中间只出现数字;
3. 表名不使用复数名词;
4. 禁用保留字;
5. 唯一索引名为uk_字段名；普通索引名则为idx_字段名;
6. 表的命名最好是加上业务名称_表的作用;
7. 库名与应用名称尽量一致;
8. 小数类型为decimal，禁止使用float和double;
9. 如果存储的字符串长度几乎相等，使用char定长字符串类型;
10. varchar是可变长字符串，不预先分配存储空间，长度不要超过5000;
11. 明确日期和时间，日期使用date类型并使用xxDate进行Java字段命名，时间使用date_time类型并使用xxTime进行Java字段命名，以示区分;
12. 枚举类型在数据库中既可以映射成int，也可以映射成varchar，视实际情况定;
13. 表必备三字段：id, gmt_create, gmt_modified;
14. 如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率;
15. 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释;
16. 字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况;
17. 单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表;
18. 合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度;
19. 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引;
20. 超过三个表禁止join;
21. 在varchar字段上建立索引时，必须指定索引长度;
22. 页面搜索严禁左模糊或者全模糊;
23. 如果有order by的场景，请注意利用索引的有序性;
24. 利用延迟关联或者子查询优化超多分页场景;
25. 建组合索引的时候，区分度最高的在最左边;
26. 不要使用count(列名)或count(常量)来替代count(*);
27. 在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句;
28. 不得使用外键与级联，一切外键概念必须在应用层解决;
29. 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性;
30. in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内;
31. 在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明;

代码风格：
1. 在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止;
2. 在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有;
3. 在if/else/for/while/do语句中必须使用大括号，即使只有一行代码，避免使用下面的形式：if (condition) statements;
4. 推荐尽量少用else， if-else的方式可以改写成：
    if(condition){
    ...
    return obj;
    }
    // 接着写else的业务逻辑代码;
5. 如果非得使用if()...else if()...else...方式表达逻辑，【强制】请勿超过3层，超过请使用状态设计模式;
6. 除常用方法（如getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性;
7. 方法中需要进行参数校验的场景：
    1） 调用频次低的方法;
    2） 执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失;
    3） 需要极高稳定性和可用性的方法;
    4） 对外提供的开放接口，不管是RPC/API/HTTP接口;
    5） 敏感权限入口;
8. 方法中不需要参数校验的场景：
    1） 极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参数检查;
    2） 底层的方法调用频度都比较高，一般不校验。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以DAO的参数校验，可以省略;
    3） 被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数;
9. 一个复杂的Service层逻辑，不应超过30行，否则需要进行逻辑规整和抽象;
10. 在业务逻辑中尽可能不要使用setter方法，而是使用构造函数或者封装成一个有逻辑意义的方法，提高代码的可读性;